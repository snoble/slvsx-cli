name: Build and Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    name: Build and Test (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
      fail-fast: false
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          
      - name: Check version format
        if: matrix.os == 'ubuntu-latest'  # Only run once
        run: |
          # Get version from workspace Cargo.toml
          CARGO_VERSION=$(grep -E '^version = "' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
          echo "Current version in Cargo.toml: $CARGO_VERSION"
          
          # Validate version format (semantic versioning)
          if [[ ! "$CARGO_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$ ]]; then
            echo "❌ ERROR: Invalid version format in Cargo.toml: $CARGO_VERSION"
            echo "   Version must follow semantic versioning (e.g., 0.1.0, 1.2.3-beta.1)"
            exit 1
          fi
          
          echo "✅ Version format is valid: $CARGO_VERSION"
          
      - name: Install dependencies (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libpng-dev zlib1g-dev
          
      - name: Install dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "cmake is pre-installed on macOS runners"
          
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Build libslvs-static
        run: |
          # Build our forked libslvs-static (includes mimalloc)
          cd libslvs-static
          mkdir -p build
          cd build
          
          # Configure with CMake
          cmake .. -DCMAKE_BUILD_TYPE=Release
          
          # Build the combined static library
          make -j$(nproc 2>/dev/null || sysctl -n hw.ncpu)
          
          echo "Libraries created:"
          ls -la *.a
          
          # The combined library uses standard memory allocation
          
      - name: Build binary for integration tests
        run: |
          export SLVS_LIB_DIR=$PWD/libslvs-static/build
          # Build the binary first (needed for integration tests)
          cargo build --release

      - name: Run tests with coverage
        run: |
          export SLVS_LIB_DIR=$PWD/libslvs-static/build
          # Run tests single-threaded because libslvs is not thread-safe
          # This prevents SIGSEGV errors when tests try to use the solver concurrently
          export RUST_TEST_THREADS=1
          # Run tests with coverage
          cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
          fail_ci_if_error: false  # Don't fail on coverage drops - use codecov.yml thresholds instead
          verbose: true
          flags: ${{ matrix.os }}
          name: slvsx-${{ matrix.os }}
          # Enable PR comments with coverage diff
          comment: always
          # Coverage thresholds are configured in codecov.yml

      - name: Build and verify documentation
        run: |
          export SLVS_LIB_DIR=$PWD/libslvs-static/build
          # Build docs and ensure there are no broken links or warnings
          cargo doc --no-deps --all-features
          # Check that docs build without errors
          cargo doc --no-deps --document-private-items
          
      - name: Build slvsx (static release)
        run: |
          export SLVS_LIB_DIR=$PWD/libslvs-static/build
          export SLVS_STATIC=1
          
          # For Linux, link statically against libgcc and libstdc++ but not glibc
          # This creates a portable binary that only depends on glibc
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            export RUSTFLAGS="-C link-arg=-static-libgcc -C link-arg=-static-libstdc++"
            # Use explicit target so RUSTFLAGS only apply to target, not proc-macros
            cargo build --release --target x86_64-unknown-linux-gnu
          else
            # For macOS, use default linking (already mostly static)
            cargo build --release
          fi
          
      - name: Verify static binary
        run: |
          # Find the binary location (different for --target builds)
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            BINARY_PATH="target/x86_64-unknown-linux-gnu/release/slvsx"
          else
            BINARY_PATH="target/release/slvsx"
          fi
          
          echo "Checking binary at: $BINARY_PATH"
          echo "Binary dependencies:"
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            ldd "$BINARY_PATH" | grep -E "(libstdc|libgcc)" || echo "No libstdc++/libgcc dependencies (good!)"
            echo "Full dependency list:"
            ldd "$BINARY_PATH"
          else
            otool -L "$BINARY_PATH"
          fi
          ls -lh "$BINARY_PATH"*
          file "$BINARY_PATH"
        
      - name: Test static binary
        run: |
          # Find the binary location (different for --target builds)
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            BINARY_PATH="target/x86_64-unknown-linux-gnu/release/slvsx"
          else
            BINARY_PATH="target/release/slvsx"
          fi
          
          # Test that the static binary actually works
          "$BINARY_PATH" --version
          "$BINARY_PATH" capabilities
          # Test with a simple JSON input (correct format for InputDocument)
          echo '{"schema":"slvs-json/1","entities":[{"type":"point","id":"p1","at":[0,0,0]}],"constraints":[],"units":"mm"}' | "$BINARY_PATH" validate -
          echo '{"schema":"slvs-json/1","entities":[{"type":"point","id":"p1","at":[0,0,0]}],"constraints":[],"units":"mm"}' | "$BINARY_PATH" export -f svg -
        
      - name: Test constraint solving
        run: |
          # Find the binary location  
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            BINARY_PATH="target/x86_64-unknown-linux-gnu/release/slvsx"
          else
            BINARY_PATH="target/release/slvsx"
          fi
          
          # Test point_on_line constraint
          echo "Testing point_on_line constraint..."
          echo '{
            "schema": "slvs-json/1",
            "units": "mm",
            "entities": [
              {"type": "point", "id": "p1", "at": [0, 0, 0]},
              {"type": "point", "id": "p2", "at": [100, 0, 0]},
              {"type": "point", "id": "p3", "at": [50, 50, 0]},
              {"type": "line", "id": "line1", "p1": "p1", "p2": "p2"}
            ],
            "constraints": [
              {"type": "fixed", "entity": "p1"},
              {"type": "fixed", "entity": "p2"},
              {"type": "point_on_line", "point": "p3", "line": "line1"}
            ]
          }' | $BINARY_PATH solve - 2>/dev/null | grep -q '"p3"' && echo "✓ point_on_line constraint test passed" || (echo "✗ point_on_line constraint test failed" && exit 1)
          
          # Test coincident constraint
          echo "Testing coincident constraint..."
          echo '{
            "schema": "slvs-json/1",
            "units": "mm",
            "entities": [
              {"type": "point", "id": "p1", "at": [0, 0, 0]},
              {"type": "point", "id": "p2", "at": [100, 0, 0]},
              {"type": "point", "id": "p3", "at": [50, 50, 0]},
              {"type": "line", "id": "line1", "p1": "p1", "p2": "p2"}
            ],
            "constraints": [
              {"type": "fixed", "entity": "p1"},
              {"type": "fixed", "entity": "p2"},
              {"type": "coincident", "at": "p3", "of": ["line1"]}
            ]
          }' | $BINARY_PATH solve - 2>/dev/null | grep -q '"p3"' && echo "✓ coincident constraint test passed" || (echo "✗ coincident constraint test failed" && exit 1)
          
      - name: Test examples
        continue-on-error: true  # Some examples use unimplemented constraints
        run: |
          chmod +x test-examples.sh
          ./test-examples.sh || echo "Some examples failed (expected - unimplemented constraints)"

      - name: Generate and verify renders
        if: matrix.os == 'ubuntu-latest'  # Only run once, on Linux
        run: |
          export SLVS_LIB_DIR=$PWD/libslvs-static/build
          
          # Find the binary location
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            BINARY_PATH="target/x86_64-unknown-linux-gnu/release/slvsx"
          else
            BINARY_PATH="target/release/slvsx"
          fi
          
          # Ensure output directory exists
          mkdir -p examples/outputs
          
          echo "Generating SVG renders..."
          
          # Generate renders for 2D examples
          for example in examples/*.json; do
            if [ -f "$example" ]; then
              name=$(basename "$example" .json)
              
              # Skip solution output files (they have a different format)
              if [[ "$name" == *_solution ]]; then
                echo "  Skipping $name (solution output file)"
                continue
              fi
              
              echo "  Rendering $name..."
              
              # Solve first (needed for export)
              "$BINARY_PATH" solve "$example" > /dev/null 2>&1 || true
              
              # Export to SVG
              "$BINARY_PATH" export -f svg "$example" -o "examples/outputs/${name}.svg" 2>&1 || true
            fi
          done
          
          # Generate multiple views for 3D examples
          echo "Generating 3D views..."
          
          # Tetrahedron - all views including isometric
          if [ -f "examples/04_3d_tetrahedron.json" ]; then
            "$BINARY_PATH" solve "examples/04_3d_tetrahedron.json" > /dev/null 2>&1
            "$BINARY_PATH" export -f svg -v xy "examples/04_3d_tetrahedron.json" -o "examples/outputs/tetrahedron_xy.svg" 2>&1
            "$BINARY_PATH" export -f svg -v xz "examples/04_3d_tetrahedron.json" -o "examples/outputs/tetrahedron_xz.svg" 2>&1
            "$BINARY_PATH" export -f svg -v yz "examples/04_3d_tetrahedron.json" -o "examples/outputs/tetrahedron_yz.svg" 2>&1
            "$BINARY_PATH" export -f svg -v isometric "examples/04_3d_tetrahedron.json" -o "examples/outputs/tetrahedron_isometric.svg" 2>&1
            echo "  Generated tetrahedron views (XY, XZ, YZ, Isometric)"
          fi
          
          # 3D basics - multiple views including isometric
          if [ -f "examples/12_3d_basics.json" ]; then
            "$BINARY_PATH" solve "examples/12_3d_basics.json" > /dev/null 2>&1
            "$BINARY_PATH" export -f svg -v xy "examples/12_3d_basics.json" -o "examples/outputs/3d_basics_xy.svg" 2>&1
            "$BINARY_PATH" export -f svg -v xz "examples/12_3d_basics.json" -o "examples/outputs/3d_basics_xz.svg" 2>&1
            "$BINARY_PATH" export -f svg -v isometric "examples/12_3d_basics.json" -o "examples/outputs/3d_basics_isometric.svg" 2>&1
            echo "  Generated 3D basics views (XY, XZ, Isometric)"
          fi
          
          # Chebyshev Linkage
          if [ -f "examples/21_chebyshev_linkage.json" ]; then
            "$BINARY_PATH" solve "examples/21_chebyshev_linkage.json" > /dev/null 2>&1
            "$BINARY_PATH" export -f svg "examples/21_chebyshev_linkage.json" -o "examples/outputs/21_chebyshev_linkage.svg" 2>&1
            echo "  Generated Chebyshev linkage"
          fi
          
          echo ""
          echo "Generated renders:"
          ls -1 examples/outputs/*.svg 2>/dev/null | wc -l | xargs echo "  Total SVG files:"
          
          echo ""
          echo "Checking for differences from committed renders..."
          
          # Check if there are any differences
          if git diff --quiet examples/outputs/*.svg 2>/dev/null; then
            echo "✅ All renders match committed versions"
          else
            echo "❌ ERROR: Generated renders differ from committed renders!"
            echo ""
            echo "Differences found:"
            git diff --stat examples/outputs/*.svg || true
            echo ""
            echo "To fix this, run: ./scripts/generate_renders.sh"
            echo "Then commit the updated renders."
            exit 1
          fi
          
      - name: Upload static binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: slvsx-static-${{ matrix.os }}
          path: |
            target/release/slvsx*
            target/x86_64-unknown-linux-gnu/release/slvsx*
          
      - name: Upload example SVGs
        uses: actions/upload-artifact@v4
        with:
          name: example-svgs-${{ matrix.os }}
          path: examples/*.svg