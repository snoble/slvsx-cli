use slvsx_core::ir::ResolvedEntity;
use std::collections::HashMap;

pub struct SlvsExporter {
    precision: usize,
}

impl Default for SlvsExporter {
    fn default() -> Self {
        Self { precision: 8 }
    }
}

impl SlvsExporter {
    pub fn new() -> Self {
        Self::default()
    }
    
    pub fn export(&self, entities: &HashMap<String, ResolvedEntity>) -> anyhow::Result<String> {
        let mut slvs = String::new();
        
        // SLVS text format header
        slvs.push_str("# SolveSpace Text Format v1\n");
        slvs.push_str("# Generated by slvsx\n\n");
        
        // Group section
        slvs.push_str("Group.h.v=00000001\n");
        slvs.push_str("Group.name=sketch\n");
        slvs.push_str("Group.visible=1\n\n");
        
        // Parameters and entities
        let mut param_id = 0x10000;
        let mut entity_id = 0x20000;
        
        for (id, entity) in entities {
            match entity {
                ResolvedEntity::Point { at } => {
                    // Each point needs 3 parameters (x, y, z)
                    for (i, coord) in at.iter().enumerate() {
                        slvs.push_str(&format!(
                            "Param.h.v={:08x}\n",
                            param_id + i
                        ));
                        slvs.push_str(&format!(
                            "Param.val={:.p$}\n\n",
                            coord,
                            p = self.precision
                        ));
                    }
                    
                    slvs.push_str(&format!("Entity.h.v={:08x}\n", entity_id));
                    slvs.push_str("Entity.type=2000\n"); // Point type
                    slvs.push_str(&format!("Entity.name={}\n", id));
                    slvs.push_str(&format!("Entity.param[0].v={:08x}\n", param_id));
                    slvs.push_str(&format!("Entity.param[1].v={:08x}\n", param_id + 1));
                    slvs.push_str(&format!("Entity.param[2].v={:08x}\n\n", param_id + 2));
                    
                    param_id += 3;
                    entity_id += 1;
                }
                ResolvedEntity::Circle { center, diameter } => {
                    // Center point parameters
                    for (i, coord) in center.iter().enumerate() {
                        slvs.push_str(&format!(
                            "Param.h.v={:08x}\n",
                            param_id + i
                        ));
                        slvs.push_str(&format!(
                            "Param.val={:.p$}\n\n",
                            coord,
                            p = self.precision
                        ));
                    }
                    
                    // Radius parameter
                    slvs.push_str(&format!("Param.h.v={:08x}\n", param_id + 3));
                    slvs.push_str(&format!(
                        "Param.val={:.p$}\n\n",
                        diameter / 2.0,
                        p = self.precision
                    ));
                    
                    slvs.push_str(&format!("Entity.h.v={:08x}\n", entity_id));
                    slvs.push_str("Entity.type=4000\n"); // Circle type
                    slvs.push_str(&format!("Entity.name={}\n", id));
                    slvs.push_str(&format!("Entity.param[0].v={:08x}\n", param_id));
                    slvs.push_str(&format!("Entity.param[1].v={:08x}\n", param_id + 1));
                    slvs.push_str(&format!("Entity.param[2].v={:08x}\n", param_id + 2));
                    slvs.push_str(&format!("Entity.param[3].v={:08x}\n\n", param_id + 3));
                    
                    param_id += 4;
                    entity_id += 1;
                }
                ResolvedEntity::Line { p1, p2 } => {
                    // Start point parameters
                    for (i, coord) in p1.iter().enumerate() {
                        slvs.push_str(&format!(
                            "Param.h.v={:08x}\n",
                            param_id + i
                        ));
                        slvs.push_str(&format!(
                            "Param.val={:.p$}\n\n",
                            coord,
                            p = self.precision
                        ));
                    }
                    
                    // End point parameters
                    for (i, coord) in p2.iter().enumerate() {
                        slvs.push_str(&format!(
                            "Param.h.v={:08x}\n",
                            param_id + 3 + i
                        ));
                        slvs.push_str(&format!(
                            "Param.val={:.p$}\n\n",
                            coord,
                            p = self.precision
                        ));
                    }
                    
                    slvs.push_str(&format!("Entity.h.v={:08x}\n", entity_id));
                    slvs.push_str("Entity.type=3000\n"); // Line segment type
                    slvs.push_str(&format!("Entity.name={}\n", id));
                    slvs.push_str(&format!("Entity.point[0].v={:08x}\n", entity_id + 0x1000));
                    slvs.push_str(&format!("Entity.point[1].v={:08x}\n\n", entity_id + 0x1001));
                    
                    param_id += 6;
                    entity_id += 1;
                }
                ResolvedEntity::Gear { center, teeth, module, .. } => {
                    // Export gear as circle with pitch radius
                    let pitch_radius = (*teeth as f64 * module) / 2.0;
                    
                    // Center point parameters
                    for (i, coord) in center.iter().enumerate() {
                        slvs.push_str(&format!(
                            "Param.h.v={:08x}\n",
                            param_id + i
                        ));
                        slvs.push_str(&format!(
                            "Param.val={:.p$}\n\n",
                            coord,
                            p = self.precision
                        ));
                    }
                    
                    // Radius parameter
                    slvs.push_str(&format!("Param.h.v={:08x}\n", param_id + 3));
                    slvs.push_str(&format!(
                        "Param.val={:.p$}\n\n",
                        pitch_radius,
                        p = self.precision
                    ));
                    
                    slvs.push_str(&format!("Entity.h.v={:08x}\n", entity_id));
                    slvs.push_str("Entity.type=4000\n"); // Circle type
                    slvs.push_str(&format!("Entity.name={}\n", id));
                    slvs.push_str(&format!("Entity.param[0].v={:08x}\n", param_id));
                    slvs.push_str(&format!("Entity.param[1].v={:08x}\n", param_id + 1));
                    slvs.push_str(&format!("Entity.param[2].v={:08x}\n", param_id + 2));
                    slvs.push_str(&format!("Entity.param[3].v={:08x}\n\n", param_id + 3));
                    
                    param_id += 4;
                    entity_id += 1;
                }
            }
        }
        
        Ok(slvs)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_slvs_exporter_default() {
        let exporter = SlvsExporter::default();
        assert_eq!(exporter.precision, 8);
    }
    
    #[test]
    fn test_slvs_exporter_new() {
        let exporter = SlvsExporter::new();
        assert_eq!(exporter.precision, 8);
    }
    
    #[test]
    fn test_export_empty() {
        let exporter = SlvsExporter::new();
        let entities = HashMap::new();
        let slvs = exporter.export(&entities).unwrap();
        assert!(slvs.contains("# SolveSpace Text Format"));
        assert!(slvs.contains("Group.h.v=00000001"));
    }
    
    #[test]
    fn test_export_point() {
        let exporter = SlvsExporter::new();
        let mut entities = HashMap::new();
        entities.insert("p1".to_string(), ResolvedEntity::Point { at: vec![10.0, 20.0, 30.0] });
        
        let slvs = exporter.export(&entities).unwrap();
        assert!(slvs.contains("Entity.type=2000")); // Point type
        assert!(slvs.contains("Entity.name=p1"));
        assert!(slvs.contains("Param.val=10.00000000"));
        assert!(slvs.contains("Param.val=20.00000000"));
        assert!(slvs.contains("Param.val=30.00000000"));
    }
    
    #[test]
    fn test_export_circle() {
        let exporter = SlvsExporter::new();
        let mut entities = HashMap::new();
        entities.insert("c1".to_string(), ResolvedEntity::Circle { 
            center: vec![0.0, 0.0, 0.0],
            diameter: 100.0
        });
        
        let slvs = exporter.export(&entities).unwrap();
        assert!(slvs.contains("Entity.type=4000")); // Circle type
        assert!(slvs.contains("Entity.name=c1"));
        assert!(slvs.contains("Param.val=50.00000000")); // radius
    }
    
    #[test]
    fn test_export_line() {
        let exporter = SlvsExporter::new();
        let mut entities = HashMap::new();
        entities.insert("l1".to_string(), ResolvedEntity::Line { 
            p1: vec![0.0, 0.0, 0.0],
            p2: vec![100.0, 100.0, 0.0]
        });
        
        let slvs = exporter.export(&entities).unwrap();
        assert!(slvs.contains("Entity.type=3000")); // Line segment type
        assert!(slvs.contains("Entity.name=l1"));
        assert!(slvs.contains("Param.val=100.00000000"));
    }
    
    #[test]
    fn test_hex_ids() {
        let exporter = SlvsExporter::new();
        let mut entities = HashMap::new();
        entities.insert("p1".to_string(), ResolvedEntity::Point { at: vec![0.0, 0.0, 0.0] });
        
        let slvs = exporter.export(&entities).unwrap();
        assert!(slvs.contains("Param.h.v=00010000"));
        assert!(slvs.contains("Entity.h.v=00020000"));
    }
}